# Integrating Your Web App with the FPL Val Town Cron

This document describes how your web app can receive and act on FPL deadline alerts generated by the Val Town cron in `cron.ts`.

**Note:** A newer polling-based approach is available using `/api/alerts/fpl-ready`. See `VALTOWN_INSTRUCTIONS.md` for details.

## Overview

- Schedule the cron to run roughly every 48 hours. Once the next FPL deadline is inside the configured lead window, the cron POSTs a JSON payload to your app’s webhook (`ALERT_WEBHOOK_URL`) and optionally sends Val Town email.
- The cron remembers the last gameweek it triggered for, so you receive at most one alert per gameweek unless you force a test send.
- You can set `ALERT_WEBHOOK_ONLY=true` to make the cron only POST and not send any emails. Your app will then decide whom to email/SMS and what contextual info to include.

## Val Town Environment Variables (sender side)

- `ALERT_WEBHOOK_URL` (required for webhook): HTTPS endpoint in your app to receive alerts
- `ALERT_WEBHOOK_AUTH` (optional): Value placed in `Authorization` header
- `ALERT_WEBHOOK_ONLY` (optional): `true` to skip Val Town emails and only POST
- `ALERT_LEAD_HOURS` (optional): default `60`; cron sends once the deadline is within this many hours
- `ALERT_TEST_FORCE_SEND` (optional): `true` to force a send on next run (bypass windows)
- `EMAIL_RECIPIENTS` (optional): comma-separated emails if you also want Val Town to email
- `SMS_EMAIL_RECIPIENTS` (optional): fallback list if `EMAIL_RECIPIENTS` is empty

## Webhook Request Contract

Method: `POST`
Headers:

- `content-type: application/json`
- `authorization: <ALERT_WEBHOOK_AUTH>` when configured

Payload (example):

```json
{
  "type": "fpl_deadline_alert",
  "gameweekId": 12,
  "gameweekName": "Gameweek 12",
  "deadlineISO": "2025-11-08T11:00:00.000Z",
  "deadlineEpochMs": 1731063600000,
  "hoursLeft": 23.5,
  "matchedThreshold": 24,
  "subject": "FPL deadline in ~24h (Gameweek 12)",
  "body": "Gameweek 12 deadline approaching\nDeadline: 2025-11-08T11:00:00.000Z UTC (Gameweek 12)\nTime left: ~23.5h (~1410m)",
  "trigger": {
    "type": "lead_hours",
    "leadHours": 60,
    "forced": false
  },
  "source": {"provider": "fantasy.premierleague.com", "endpoint": "/api/bootstrap-static/"}
}
```

Response: return `200 OK` as soon as you enqueue your own processing; include retries in your infra if desired.

Note: `matchedThreshold` is retained for backward compatibility and now equals `Math.ceil(hoursLeft)` at the moment the alert is emitted.

## Security Options

- Shared secret header: set `ALERT_WEBHOOK_AUTH` and verify `Authorization` server-side.
- Optional HMAC signing (recommended):
  - Set `ALERT_WEBHOOK_SIGNING_SECRET` in Val Town.
  - The cron sends header `x-signature-sha256` computed as `sha256(secret + ":" + rawBody)`.
  - Verify before processing.

Node/Express verification example:

```ts
import crypto from "node:crypto";

function sha256Hex(buf: Buffer) {
  return crypto.createHash("sha256").update(buf).digest("hex");
}

app.post("/webhooks/fpl-deadline", express.raw({ type: "application/json" }), (req, res) => {
  const provided = req.header("x-signature-sha256");
  const expected = sha256Hex(Buffer.from(`${process.env.ALERT_WEBHOOK_SIGNING_SECRET}:${req.body.toString("utf8")}`));
  if (!provided || provided !== expected) return res.status(401).send("bad signature");
  const alert = JSON.parse(req.body.toString("utf8"));
  // ... handle alert
  res.json({ ok: true });
});
```

TanStack (API route) verification example:

```ts
// File: app/routes/api/webhooks.fpl-deadline.ts
import { createAPIFileRoute } from "@tanstack/start/api";

function sha256HexFromString(input: string) {
  const cryptoNode = require("node:crypto");
  return cryptoNode.createHash("sha256").update(input).digest("hex");
}

export const Route = createAPIFileRoute("/api/webhooks/fpl-deadline")({
  POST: async ({ request }) => {
    const provided = request.headers.get("x-signature-sha256");
    const raw = await request.text(); // IMPORTANT: read raw text for signature
    const expected = sha256HexFromString(`${process.env.ALERT_WEBHOOK_SIGNING_SECRET}:${raw}`);
    if (!provided || provided !== expected) {
      return new Response("bad signature", { status: 401 });
    }

    const alert = JSON.parse(raw);
    // TODO: load users, evaluate windows, send emails
    // await send(alert)

    return Response.json({ ok: true });
  },
});
```

## Timezone + “Evening Before” Logic (app side)

Because the cron may run hours (or even a full day) before the desired notification window, your app should queue the actual send for each user:

1) Convert `deadlineEpochMs` to the user’s timezone (e.g., `America/New_York`).
2) Compute the preferred “evening before” window (for example, previous day 19:00–21:00 local).
3) When you receive the webhook, schedule a job for that window (or fire immediately if already inside it).
4) Store per-user state: lastSentGameweekId, queued job id / status, do-not-disturb settings.

Pseudo:

```ts
type User = {
  id: string;
  email: string;
  tz: string; // e.g., "America/New_York"
  windowStart: string; // "19:00"
  windowEnd: string; // "21:00"
  lastSentGw?: number;
};

function shouldNotifyUser(now: Date, user: User, deadlineEpochMs: number, gameweekId: number): boolean {
  if (user.lastSentGw === gameweekId) return false;
  const deadlineLocal = toUserLocal(deadlineEpochMs, user.tz); // implement with a TZ lib
  const eveningBefore = startOfDay(deadlineLocal).minus({ days: 1 }); // midnight of the prior day
  const [h1, m1] = user.windowStart.split(":").map(Number);
  const [h2, m2] = user.windowEnd.split(":").map(Number);
  const windowStart = eveningBefore.set({ hour: h1, minute: m1 });
  const windowEnd = eveningBefore.set({ hour: h2, minute: m2 });
  return now >= windowStart && now <= windowEnd;
}

function queueUserNotification(user: User, alert: AlertPayload) {
  const sendAt = computeWindowStart(user, alert.deadlineEpochMs);
  if (sendAt <= new Date()) {
    return sendEmailNow(user, alert);
  }
  return scheduleJob(user.id, sendAt, alert);
}
```

## Example Handlers

Express:

```ts
app.post("/webhooks/fpl-deadline", async (req, res) => {
  const auth = req.get("authorization");
  if (process.env.ALERT_WEBHOOK_AUTH && auth !== process.env.ALERT_WEBHOOK_AUTH) {
    return res.status(401).send("unauthorized");
  }
  const alert = req.body as any; // matches payload example above
  // Load candidate users for FPL alerts
  const users = await loadUsers();
  const operations: Promise<any>[] = [];
  for (const user of users) {
    if (await hasAlreadyQueued(user.id, alert.gameweekId)) continue;
    operations.push(queueUserNotification(user, alert));
    await markUserQueued(user.id, alert.gameweekId);
  }
  await Promise.all(operations);
  return res.send({ ok: true, queued: operations.length });
});
```

## Email Delivery: Who sends what?

- Val Town option: use its `std/email` from the cron. This can email the val owner by default or specific recipients if you set `EMAIL_RECIPIENTS`. No separate email provider setup is required for those sends.
- Your app (recommended for multi-user): handle delivery using your own provider (e.g., SES, SendGrid, Resend, Postmark). This lets you apply user-level logic, templates, and analytics. The cron then runs with `ALERT_WEBHOOK_ONLY=true` and just triggers your app.
- When testing with `ALERT_TEST_FORCE_SEND=true`, the cron fires immediately but does not update its dedupe state, so the real alert will still emit once the lead window is reached after you clear the flag.

## Idempotency

- The cron deduplicates per gameweek using Val Town blob storage, so you receive one webhook per gameweek unless you force a send.
- Deduplicate per user per `gameweekId`.
- Store a send record with a unique key like `fpl:${gameweekId}:${userId}`.

## Testing Checklist

- Set `ALERT_TEST_FORCE_SEND=true` on Val Town and run the cron manually.
- Verify your endpoint receives the payload and returns 200.
- Temporarily lower `ALERT_LEAD_HOURS` (e.g., `4`) to ensure the cron fires quickly during tests.
- Check your provider’s logs to confirm emails are sent.

## Next Actions

1. Implement the webhook endpoint described in INTEGRATION.md#Webhooks (validate authorization and optional x-signature-sha256, enqueue or trigger your own notification workflow).
2. Build the scheduling/notification logic in your app per the “Timezone + Evening Before Logic” section—store user prefs, dedupe per gameweekId, and schedule sends inside each user’s window.
3. Configure Val Town env vars (ALERT_WEBHOOK_URL, auth/signing secrets, ALERT_LEAD_HOURS, recipient lists, etc.) and set the cron cadence so it actually starts POSTing alerts to your endpoint.
4. Run the test checklist (force send, lower lead hours) to validate end-to-end delivery once your webhook is live.
